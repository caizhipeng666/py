# 对象

> 如果把变量想象为盒子，那么无法解释Python中的赋值   
在Pytthon中, 应该把变量视作便利贴

**对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了**

可变对象|不可变对象
---|---
list<br>bytearray<br>array.array<br><vr>collections.deque<br>memoryview|tuple<br>str<br>bytes|


### 可散列对象
* 支持hash(), 并通过__hash__()得到的散列值不变
* 支持__eq__()来检测相等性
* 若a == b, 则hash(a) == hash(b)

### 散列表算法
> 获取my_dict["key"]的值

```
1. 调用hash("key")来计算散列值
Loop:
2. 把得到的散列值的最低几位当作偏移量, 在散列表里查找表元
3. 若查找为空, 则抛出KeyError
4. 否则, 表元里会有一对found_key: found_value,
   检查"key"散列值 == found_key散列值, 
   如果相等则返回found_value
   如果不相等 -> 散列冲突: 再取几位散列值结合在一起作偏移量
```
---

### 强引用

```
名字和对象的关联, 增加引用计数, 进而影响目标对象的生命周期

  int实例、str实例、list实例、tuple实例

import sys
sys.getrefcount(xxx)
来查看xxx的引用计数
```

### 弱引用
```
在保留引用的前提下, 不增加计数, 不阻止目标被回收

  list子类、dict子类
  set实例
  自定义object

> 相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来
```
```python
不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）
基本的 list 和 dict 实例不能作为所指对象
```

---

#### 在变量和单例值之间比较时，应该使用 is
```
is 运算符比 == 速度快,
因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是直接比较两个整数 ID。
而 a == b 是语法糖，等同于 a.__eq__(b)
继承自 object 的 __eq__ 方法比较两个对象的 ID，结果与 is 一样
```
---

##### int

> Cpython: 如果有一个整型对象, 而且它能被存进一个机器字中, 那它的散列值就是本身

> 比较字符串或整数是否相等时，应该使用 ==

##### dict

> 字典使用了散列表, 由于是稀疏数组, 所有空间上效率低下,

* 使用元组取代, 无需把记录中字段的名字在每个元素里都存一遍

##### tuple
```
a = (1, 1)
b = (1, 1)
a is b

>>> True

a = (1, ["1"])
b = (1, ["1"])
a is b

>>> False
```
