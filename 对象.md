# 对象

内容|description
---|---
[变量](#变量)|赋予引用
[可变与不可变对象](可变与不可变对象)|基础数据结构分类
[可散列对象](#可散列对象)|hash()相等
[散列表算法](#散列表算法)|解决散列冲突
[强引用](#强引用)|增加引用计数
[弱引用](#弱引用)|保留引用, 不增加引用
[is和==](#is和==)|is不能重载, 是内存地址比较<br>==是值比较
[int](#int)|散列值是本身
[dict](#dict)|散列表, 稀疏数组
[tuple](#tuple)|
[class](#class)|

---

### 变量
> 变量保存的是引用, 为现有的变量赋值, 不会修改之前绑定的变量, 只会为现有的变量重新绑定!

**对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了**

---

### 可变与不可变对象
可变对象|不可变对象
---|---
list<br>dict<br>bytearray<br>array.array<br><vr>collections.deque<br>memoryview|int<br>tuple<br>str<br>bytes|

---

### 可散列对象
* 支持hash(), 并通过__hash__()得到的散列值不变
* 支持\_\_eq\_\_()来检测相等性
* 若a == b, 则hash(a) == hash(b)

### 散列表算法
> 获取my_dict["key"]的值

```
1. 调用hash("key")来计算散列值
Loop:
2. 把得到的散列值的最低几位当作偏移量, 在散列表里查找表元
3. 若查找为空, 则抛出KeyError
4. 否则, 表元里会有一对found_key: found_value,
   检查"key"散列值 == found_key散列值, 
   如果相等则返回found_value
   如果不相等 -> 散列冲突: 再取几位散列值结合在一起作偏移量
```
---

### 强引用

```
名字和对象的关联, 增加引用计数, 进而影响目标对象的生命周期

  int实例、str实例、list实例、tuple实例

import sys
sys.getrefcount(xxx)
来查看xxx的引用计数
```

### 弱引用
```
在保留引用的前提下, 不增加计数, 不阻止目标被回收

  list子类、dict子类
  set实例
  自定义object

> 相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来
```
```python
不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）
基本的 list 和 dict 实例不能作为所指对象
```

---

### is和==
> 在变量和单例值(如,bool)之间比较时，应该使用 is

```
is 运算符比 == 速度快,
因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是直接比较两个整数 ID。
而 a == b 是语法糖，等同于 a.__eq__(b)
继承自 object 的 __eq__ 方法比较两个对象的 ID，结果与 is 一样
```
---

##### int

> Cpython: 如果有一个整型对象, 而且它能被存进一个机器字中, 那它的散列值就是本身

> 比较字符串或整数是否相等时，应该使用 ==

##### dict

> 字典使用了散列表, 由于是稀疏数组, 所有空间上效率低下,

* 使用元组取代, 无需把记录中字段的名字在每个元素里都存一遍

##### tuple
```python
a = (1, 1)
b = (1, 1)
a is b

>>> True

a = (1, ["1"])
b = (1, ["1"])
a is b

>>> False
```

##### class
操作|desc
---|---
获取class_name|type(self).\_\_name\_\_
设置只读属性|@property
获取不到元素时|\_\_getattr\_\_

```python
class Test:
    def __init__(self):
        self.__x = "czp"

    # 拿到class_name
    def get_name(self):
        return type(self).__name__

    # 只读属性
    @property
    def x(self):
        return self.__x

    # 获取不到元素时
    def __getattr__(self, item):
        if ...:
            pass
        else:
            raise AttributeError("...")
```
