# 列表
### 切片
```python
data = [1, 2, 3, 4, 5, 6]
test = slice(2, 4, 2)
print(data[test])
```

### 读取元素属性
* itemgetter
* attrgetter

> 直接操作元素的时候

```python
from operator import itemgetter

data = [
    ("a", 1, 2, 3, 4),
    ("b", 11, 22, 33, 44),
    ("a", 3, 2, 3, 4),
    ("f", -1, 2, 3, 4),
]

test = itemgetter(1, 0)
for i in data:
    print(test(i))

"""用来排序"""
for i in sorted(data, key=itemgetter(1, 0)):
    print(i)
```

> 需要操作对象的属性

```python
"""a对象的c属性是一个b对象"""
a_class = namedtuple("a_class", "a b c")
b_class = namedtuple("b_class", "x y z")

data = [a_class(1, 2, b_class("a1", "b1", "c1")),
        a_class(3, 4, b_class("a2", "b2", "c2")),
        a_class(5, 6, b_class("a3", "b3", "c3"))]

test = attrgetter("c.x")
for i in sorted(data, key=test):
    print(test(i))
```

> 需要操作对象的方法

```python
from operator import methodcaller


class A:
    def get(self):
        return "A"


data = [A(), A(), A()]

test = methodcaller("get")
for i in data:
    print(test(i))

```

### 迭代列表
func|desc
---|---
chain|拼接
accumulate|累加
compress|漏斗


#### chain
```python
list(chain(['I','love'],['python'],['very', 'much']))
['I', 'love', 'python', 'very', 'much']
```

#### accumulate
```python
accumulate(iterable, func)
```

### 分组
```python
from itertools import groupby

data = [
    {"name": "czp", "money": "1"},
    {"name": "cpp", "money": "1"},
    {"name": "czp", "money": "0.5"},
    {"name": "cpp", "money": "2"},
    {"name": "c2p", "money": "0.5"},
]
test = itemgetter("money")
data.sort(key=test)

for money, items in groupby(data, key=test):
    print(money)
    for i in items:
        print(i)
```

> 需要先进行排序