内容|description
---|---
[class_name](#class_name)|type(self).\_\_name\_\_
[只读属性](#只读属性)|@property
[获取元素](#获取元素)|\_\_getattr\_\_
[节省空间](#节省空间)|\_\_slots\_\_
[虚拟子类](#虚拟子类)|不需要实现abstractmethod
[所有继承](#所有继承)|\_\_mro\_\_
[内置继承](#内置继承)|CPython定义的内置类<br>特殊方法不会被覆盖

---

### class_name
```python
class Test:
    def get_name(self):
        return type(self).__name__
```

### 只读属性
```python
class Test:
    def __init__(self):
        self.__x = "czp"

    @property
    def x(self):
        return self.__x
```

### 获取元素
```python
class Test:
    # 获取不到元素时
    def __getattr__(self, item):
        if ...:
            pass
        else:
            raise AttributeError("...")
```

### 节省空间
```python
class Test:
    """告诉解释器:所有属性都在这了"""
    __slots__ = ("__x", "__y")

    def __init__(self):
        self.__x = ...
        self.__y = ...
```

> 继承的话, 每个子类都需要定义\_\_slots\_\_, 否则会被解释器忽略

### 虚拟子类
```python
import abc


class Test(abc.ABC):
    def p(self):
        pass

    @abc.abstractmethod
    def x(self):
        pass


class Test2(metaclass=abc.ABCMeta):
    def p(self):
        pass


@Test.register
class A:
    pass


a = A()
```

### 所有继承
```python
import abc


class Test(abc.ABC):
    def p(self):
        pass

    @abc.abstractmethod
    def x(self):
        pass


@Test.register
class A:
    pass

"""1.所有继承"""
Test.__mro__

>>> (<class '__main__.Test'>, <class 'abc.ABC'>, <class 'object'>)


class Test2(Test):
    def x(self):
        pass

"""2.不含虚拟"""
Test.__subclasses__()

>>> [<class '__main__.Test2'>]

"""3.只有抽象基类拥有"""(3.7用dir发现没有这个属性了)
_abc__registery
```

### 内置继承
```python
class Test(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value]*3)


"""init无效"""
test = Test(czp="cool")
test

>>> {'czp': 'cool'}

"""[]设置有效"""
test["money"] = "null"
test

>>> {'czp': 'cool', 'money': ['null', 'null', 'null']}

"""update无效"""
test.update(play="1")
test

>>> {'czp': 'cool', 'money': ['null', 'null', 'null'], 'play': '1'}
```
